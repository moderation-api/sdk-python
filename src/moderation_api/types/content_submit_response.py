# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

from typing import Dict, List, Union, Optional
from typing_extensions import Literal, TypeAlias

from .._models import BaseModel

__all__ = [
    "ContentSubmitResponse",
    "Author",
    "AuthorBlock",
    "AuthorTrustLevel",
    "Content",
    "ContentModifiedUnionMember1ContentModifiedUnionMember1Item",
    "ContentModifiedUnionMember1ContentModifiedUnionMember1ItemText",
    "ContentModifiedUnionMember1ContentModifiedUnionMember1ItemImage",
    "ContentModifiedUnionMember1ContentModifiedUnionMember1ItemVideo",
    "ContentModifiedUnionMember1ContentModifiedUnionMember1ItemAudio",
    "Evaluation",
    "Insight",
    "InsightSentimentInsight",
    "InsightLanguageInsight",
    "Meta",
    "Policy",
    "PolicyClassifierOutput",
    "PolicyClassifierOutputLabel",
    "PolicyEntityMatcherOutput",
    "PolicyEntityMatcherOutputMatch",
    "Recommendation",
    "Error",
]


class AuthorBlock(BaseModel):
    reason: Optional[str] = None
    """The moderators reason why the author was blocked or suspended."""

    until: Optional[float] = None
    """The timestamp until which they are blocked if the author is suspended."""


class AuthorTrustLevel(BaseModel):
    level: float
    """Author trust level (-1, 0, 1, 2, 3, or 4)"""

    manual: bool
    """True if the trust level was set manually by a moderator"""


class Author(BaseModel):
    id: str
    """Author ID in Moderation API"""

    block: Optional[AuthorBlock] = None
    """Block or suspension details, if applicable. Null if the author is enabled."""

    status: Literal["enabled", "suspended", "blocked"]
    """Current author status"""

    trust_level: AuthorTrustLevel

    external_id: Optional[str] = None
    """The author's ID from your system"""


class ContentModifiedUnionMember1ContentModifiedUnionMember1ItemText(BaseModel):
    text: str
    """The content text"""

    type: Literal["text"]


class ContentModifiedUnionMember1ContentModifiedUnionMember1ItemImage(BaseModel):
    type: Literal["image"]

    url: str
    """A public URL of the image content"""


class ContentModifiedUnionMember1ContentModifiedUnionMember1ItemVideo(BaseModel):
    type: Literal["video"]

    url: str
    """A public URL of the video content"""


class ContentModifiedUnionMember1ContentModifiedUnionMember1ItemAudio(BaseModel):
    type: Literal["audio"]

    url: str
    """The URL of the audio content"""


ContentModifiedUnionMember1ContentModifiedUnionMember1Item: TypeAlias = Union[
    ContentModifiedUnionMember1ContentModifiedUnionMember1ItemText,
    ContentModifiedUnionMember1ContentModifiedUnionMember1ItemImage,
    ContentModifiedUnionMember1ContentModifiedUnionMember1ItemVideo,
    ContentModifiedUnionMember1ContentModifiedUnionMember1ItemAudio,
]


class Content(BaseModel):
    id: str
    """The unique identifier for the content.

    Either the contentId provided by you or an autogenerated ID.
    """

    masked: bool
    """Whether any values have been masked."""

    modified: Union[str, Dict[str, ContentModifiedUnionMember1ContentModifiedUnionMember1Item], None] = None
    """The modified content, if any."""


class Evaluation(BaseModel):
    flag_probability: float
    """The probability that the content should be flagged."""

    flagged: bool
    """Whether the content was flagged by any policy."""

    severity_score: float
    """The severity score of the content.

    A higher score indicates more severe content.
    """

    unicode_spoofed: Optional[bool] = None
    """Whether the content was flagged for Unicode spoofing."""


class InsightSentimentInsight(BaseModel):
    id: Literal["sentiment"]

    probability: float

    type: Literal["insight"]

    value: Optional[Literal["positive", "neutral", "negative"]] = None


class InsightLanguageInsight(BaseModel):
    id: Literal["language"]

    probability: float

    type: Literal["insight"]

    value: Optional[str] = None


Insight: TypeAlias = Union[InsightSentimentInsight, InsightLanguageInsight]


class Meta(BaseModel):
    channel_key: str
    """The unique key of the channel where the content was handled.

    Either the channel provided by you or automatically routed.
    """

    status: Literal["success", "partial_success"]

    timestamp: float

    usage: float

    processing_time: Optional[str] = None


class PolicyClassifierOutputLabel(BaseModel):
    id: str

    flagged: bool

    probability: float


class PolicyClassifierOutput(BaseModel):
    id: str
    """The unique identifier for the classifier output."""

    flagged: bool

    probability: float

    type: Literal["classifier"]

    flagged_fields: Optional[List[str]] = None
    """The keys of the flagged fields if submitting an object."""

    labels: Optional[List[PolicyClassifierOutputLabel]] = None


class PolicyEntityMatcherOutputMatch(BaseModel):
    match: str

    probability: float

    span: List[object]


class PolicyEntityMatcherOutput(BaseModel):
    id: str

    flagged: bool

    matches: List[PolicyEntityMatcherOutputMatch]

    probability: float

    type: Literal["entity_matcher"]

    flagged_fields: Optional[List[str]] = None


Policy: TypeAlias = Union[PolicyClassifierOutput, PolicyEntityMatcherOutput]


class Recommendation(BaseModel):
    action: Literal["review", "allow", "reject"]
    """The action to take based on the recommendation"""

    reason_codes: List[Literal["severity_reject", "severity_review", "author_block", "dry_run"]]
    """The reason code for the recommendation.

    Can be used to display a reason to the user.
    """


class Error(BaseModel):
    id: str

    message: str


class ContentSubmitResponse(BaseModel):
    author: Optional[Author] = None
    """The author of the content if your account has authors enabled.

    Requires you to send authorId when submitting content.
    """

    content: Content
    """Potentially modified content."""

    evaluation: Evaluation
    """The evaluation of the content after running the channel policies."""

    insights: List[Insight]
    """Results of all insights enabled in the channel."""

    meta: Meta
    """Metadata about the moderation request"""

    policies: List[Policy]
    """Results of all policies in the channel. Sorted by highest probability."""

    recommendation: Recommendation
    """The recommendation for the content based on the evaluation."""

    errors: Optional[List[Error]] = None
    """Policies that had errors"""
